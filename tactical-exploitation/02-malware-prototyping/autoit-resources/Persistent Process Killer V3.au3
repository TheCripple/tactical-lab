#region ;**** Directives created by AutoIt3Wrapper_GUI ****
#AutoIt3Wrapper_UseUpx=n
#AutoIt3Wrapper_Run_Tidy=y
#endregion ;**** Directives created by AutoIt3Wrapper_GUI ****

;~ Coded by Ian Maxwell (llewxam)
;~ AutoIt 3.3.6.1

#include &lt;WindowsConstants.au3&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;needed for $WS_CAPTION, $WS_VSCROLL, $WM_COMMAND
#include &lt;array.au3&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;needed for _ArrayAdd, _ArrayDelete, _ArrayUnique, _ArraySort, _ArrayBinarySearch
#include &lt;ProgressConstants.au3&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;needed for $PBS_SMOOTH, $PBS_MARQUEE
#include &lt;GuiListBox.au3&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;needed for $LBS_NOTIFY, $LBS_SORT, $LBS_NOSEL, $GUI_RUNDEFMSG, _GUICtrlListBox_* functions

AdlibRegister("_Alive", 50)
AdlibRegister("_Scan")

$exceptionList = "PPK3.exe,[System
 
Process],System,smss.exe,csrss.exe,wininit.exe,csrss.exe,services.exe,winlogon.exe,lsass.exe,lsm.exe,svchost.exe,atiesrxx.exe,audiodg.exe,CTAudSvc.exe,atieclxx.exe,spoolsv.exe,taskhost.exe,dwm.exe,explorer.exe,rundll32.exe,GoogleCrashHandler.exe,MOM.exe,CCC.exe,SearchIndexer.exe,wmpnetwk.exe,SearchProtocolHost.exe,SearchFilterHost.exe,dllhost.exe,mpcmdrun.exe,msiexec.exe,unsecapp.exe,vds.exe,WmiPrvSE.exe"
$exceptions = StringSplit($exceptionList, ",") ;list of what not to kill
Local $pList[1] ;list of running processes
$pListOld = $pList ;to compare a previous process list, so $liveProc is only updated if the process list changes
Local $killList[1] ;list of processes to kill
$liveProcCount = 0 ;tally of processes running
$killProcCount = 0 ;tally of processes to be killed
$killListTrimmed = False ;flag for detecting when $killList has been trimmed
$goNuclear = False ;flag set by /nuke command line switch
$started = False ;used in Nuke mode to avoid crashes due to no GUI


;check for and run nuke
If $CmdLine[0] Then ;many viruses/spyware apps suppress EXEs from running, nuke mode is meant to sneak
&nbsp; &nbsp; For $c = 1 To $CmdLine[0] ;PPK in before it can be suppressed. &nbsp;Just run "ppk /nuke" or "ppk nuke" repeatedly until it starts
&nbsp; &nbsp; &nbsp; &nbsp; If StringLower($CmdLine[$c]) == "/nuke" Or StringLower($CmdLine[$c]) == "nuke" Then $goNuclear = True
&nbsp; &nbsp; Next
EndIf
If $goNuclear == True Then
&nbsp; &nbsp; $pListRaw = ProcessList()
&nbsp; &nbsp; If @error Then
&nbsp; &nbsp; &nbsp; &nbsp; MsgBox(48, "ERROR", "The process list could not be built!")
&nbsp; &nbsp; &nbsp; &nbsp; Exit
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Local $pListTemp[1] ;used to get the list of running processes down to a 1-dimensional array
&nbsp; &nbsp; For $a = 1 To $pListRaw[0][0]
&nbsp; &nbsp; &nbsp; &nbsp; _ArrayAdd($pListTemp, $pListRaw[$a][0])
&nbsp; &nbsp; Next
&nbsp; &nbsp; _ArrayDelete($pListTemp, 0)
&nbsp; &nbsp; $pList = _ArrayUnique($pListTemp)

&nbsp; &nbsp; If $pList[0] &gt; 0 Then
&nbsp; &nbsp; &nbsp; &nbsp; Local $killList[1]
&nbsp; &nbsp; &nbsp; &nbsp; For $a = 1 To $pList[0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $b = 1 To $exceptions[0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If StringLower($pList[$a]) == StringLower($exceptions[$b]) Then ContinueLoop (2)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _Execute($pList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ArrayAdd($killList, $pList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; _ArrayDelete($killList, 0)
&nbsp; &nbsp; $goNuclear = False
EndIf


;configure GUI
$vert = ((@DesktopHeight - 80) / 3) - 40
$PPKGUI = GUICreate("Persistent Process Killer", 200, @DesktopHeight - 70, @DesktopWidth - 205, 0, $WS_CAPTION)
$alive = GUICtrlCreateProgress(5, 5, 190, 20, BitOR($PBS_SMOOTH, $PBS_MARQUEE)) ;just to let the user know the app is still running
$aliveStatus = 0
$closeButton = GUICtrlCreateButton("Close", 75, 35, 50, 20)
$liveProcLabel = GUICtrlCreateLabel("Running Processes:", 5, 65, 190)
$liveProc = GUICtrlCreateList("", 5, 80, 190, $vert, BitOR($WS_VSCROLL, $LBS_NOTIFY, $LBS_SORT))
$killProcLabel = GUICtrlCreateLabel("Processes to Kill:", 5, $vert + 85, 190)
$killProc = GUICtrlCreateList("", 5, $vert + 100, 190, $vert, BitOR($WS_VSCROLL, $LBS_NOTIFY, $LBS_SORT))
GUICtrlCreateLabel("Errors:", 5, $vert * 2 + 105)
$errors = GUICtrlCreateList("", 5, $vert * 2 + 120, 190, $vert, BitOR($WS_VSCROLL, $LBS_SORT, $LBS_NOSEL))
GUISetState(@SW_SHOW, $PPKGUI)
GUIRegisterMsg($WM_COMMAND, "_WM_COMMAND")
WinSetOnTop("Persistent Process Killer", "", 1)


;perform initial scan for running processes
$pListRaw = ProcessList()
If @error Then
&nbsp; &nbsp; MsgBox(48, "ERROR", "The process list could not be built!")
&nbsp; &nbsp; Exit
EndIf
Local $pListTemp[1]
For $a = 1 To $pListRaw[0][0]
&nbsp; &nbsp; _ArrayAdd($pListTemp, $pListRaw[$a][0])
Next
_ArrayDelete($pListTemp, 0)
$pList = _ArrayUnique($pListTemp)

If $pList[0] &gt; 0 Then
&nbsp; &nbsp; For $a = 1 To $pList[0]
&nbsp; &nbsp; &nbsp; &nbsp; For $b = 1 To $exceptions[0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If StringLower($pList[$a]) == StringLower($exceptions[$b]) Then ContinueLoop (2)
&nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($liveProc, $pList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; $liveProcCount += 1
&nbsp; &nbsp; Next
EndIf
GUICtrlSetData($liveProcLabel, "Running Processes: " &amp; $liveProcCount)

For $a = 1 To UBound($killList) - 1
&nbsp; &nbsp; GUICtrlSetData($killProc, $killList[$a])
&nbsp; &nbsp; $killProcCount += 1
Next
GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)

$started = True ;now all GUI controls will be used


;main loop
Do
&nbsp; &nbsp; $msg = GUIGetMsg()
&nbsp; &nbsp; If $msg = $closeButton Then _Exit()

&nbsp; &nbsp; For $a = 1 To UBound($killList) - 1

&nbsp; &nbsp; &nbsp; &nbsp; ;placed this check at beginning and end of loop so when $killList is decreased an out-of-range error will be avoided
&nbsp; &nbsp; &nbsp; &nbsp; If $killListTrimmed == True Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $killListTrimmed = False
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExitLoop
&nbsp; &nbsp; &nbsp; &nbsp; EndIf

&nbsp; &nbsp; &nbsp; &nbsp; If ProcessExists($killList[$a]) Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _Execute($killList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; EndIf

&nbsp; &nbsp; &nbsp; &nbsp; If $killListTrimmed == True Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $killListTrimmed = False
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExitLoop
&nbsp; &nbsp; &nbsp; &nbsp; EndIf
&nbsp; &nbsp; Next
Until 1 = 2


Func _Scan()
&nbsp; &nbsp; If $started == True Then
&nbsp; &nbsp; &nbsp; &nbsp; $pListOld = $pList
&nbsp; &nbsp; &nbsp; &nbsp; $pListRaw = ProcessList()
&nbsp; &nbsp; &nbsp; &nbsp; If @error Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MsgBox(48, "ERROR", "The process list could not be built!")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exit
&nbsp; &nbsp; &nbsp; &nbsp; EndIf

&nbsp; &nbsp; &nbsp; &nbsp; Local $pListTemp[1]
&nbsp; &nbsp; &nbsp; &nbsp; For $a = 1 To $pListRaw[0][0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ArrayAdd($pListTemp, $pListRaw[$a][0])
&nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; _ArrayDelete($pListTemp, 0)
&nbsp; &nbsp; &nbsp; &nbsp; $pList = _ArrayUnique($pListTemp)

&nbsp; &nbsp; &nbsp; &nbsp; If $pList[0] &gt; 0 Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $refresh = False ;assume a refresh of $liveProc is not needed

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If $pList[0] &lt;&gt; $pListOld[0] Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $refresh = True ;different number of elements = refresh needed
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Else
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $z = 1 To $pList[0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If $pList[$z] &lt;&gt; $pListOld[$z] Then $refresh = True ;something is not matching up, so a refresh is needed
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndIf

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If $refresh = True Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $liveProcCount = 0
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_BeginUpdate($liveProc)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_ResetContent($liveProc)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $a = 1 To $pList[0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $b = 1 To $exceptions[0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If StringLower($pList[$a]) == StringLower($exceptions[$b]) Then ContinueLoop (2)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_AddString($liveProc, $pList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $liveProcCount += 1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_EndUpdate($liveProc)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($liveProcLabel, "Running Processes: " &amp; $liveProcCount)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndIf
&nbsp; &nbsp; &nbsp; &nbsp; EndIf
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Return
EndFunc &nbsp; ;==&gt;_Scan


Func _Execute($victim)
&nbsp; &nbsp; $killed = False
&nbsp; &nbsp; $delay = TimerInit()
&nbsp; &nbsp; Do
&nbsp; &nbsp; &nbsp; &nbsp; ProcessClose($victim)
&nbsp; &nbsp; &nbsp; &nbsp; If @error Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $status = @error
&nbsp; &nbsp; &nbsp; &nbsp; Else
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $killed = True
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExitLoop
&nbsp; &nbsp; &nbsp; &nbsp; EndIf
&nbsp; &nbsp; &nbsp; &nbsp; Sleep(50)
&nbsp; &nbsp; Until TimerDiff($delay) &gt; 1000

&nbsp; &nbsp; If $killed = False Then
&nbsp; &nbsp; &nbsp; &nbsp; If $started == True Then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($errors, $victim &amp; " could not be killed! (" &amp; $status &amp; ")")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ArraySort($killList)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $index = _ArrayBinarySearch($killList, $victim)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ArrayDelete($killList, $index)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_BeginUpdate($killProc)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_ResetContent($killProc)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $a = 1 To UBound($killList) - 1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($killProc, $killList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_EndUpdate($killProc)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $killProcCount -= 1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $killListTrimmed = True
&nbsp; &nbsp; &nbsp; &nbsp; EndIf
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Return
EndFunc &nbsp; ;==&gt;_Execute


Func _liveProc_DoubleClick()
&nbsp; &nbsp; $sListItem = GUICtrlRead($liveProc)
&nbsp; &nbsp; If $sListItem &lt;&gt; "" Then
&nbsp; &nbsp; &nbsp; &nbsp; _ArrayAdd($killList, $sListItem)
&nbsp; &nbsp; &nbsp; &nbsp; $killProcCount += 1
&nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($killProc, $sListItem)
&nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Return
EndFunc &nbsp; ;==&gt;_liveProc_DoubleClick


Func _killProc_DoubleClick()
&nbsp; &nbsp; $sListItem = GUICtrlRead($killProc)
&nbsp; &nbsp; If $sListItem &lt;&gt; "" Then
&nbsp; &nbsp; &nbsp; &nbsp; $killProcCount = 0
&nbsp; &nbsp; &nbsp; &nbsp; _ArraySort($killList)
&nbsp; &nbsp; &nbsp; &nbsp; $index = _ArrayBinarySearch($killList, $sListItem)
&nbsp; &nbsp; &nbsp; &nbsp; _ArrayDelete($killList, $index)
&nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_BeginUpdate($killProc)
&nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_ResetContent($killProc)
&nbsp; &nbsp; &nbsp; &nbsp; For $a = 1 To UBound($killList) - 1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($killProc, $killList[$a])
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $killProcCount += 1
&nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; _GUICtrlListBox_EndUpdate($killProc)
&nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)
&nbsp; &nbsp; &nbsp; &nbsp; $killListTrimmed = True
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Return
EndFunc &nbsp; ;==&gt;_killProc_DoubleClick


Func _WM_COMMAND($hWnd, $msg, $wParam, $lParam)
&nbsp; &nbsp; Local $nNotifyCode = BitShift($wParam, 16)
&nbsp; &nbsp; Local $nID = BitAND($wParam, 0xFFFF)
&nbsp; &nbsp; Local Const $LBN_DBLCLK = 2

&nbsp; &nbsp; Switch $nID
&nbsp; &nbsp; &nbsp; &nbsp; Case $liveProc
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Switch $nNotifyCode
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Case $LBN_DBLCLK
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _liveProc_DoubleClick()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndSwitch
&nbsp; &nbsp; &nbsp; &nbsp; Case $killProc
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Switch $nNotifyCode
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Case $LBN_DBLCLK
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _killProc_DoubleClick()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndSwitch
&nbsp; &nbsp; EndSwitch
&nbsp; &nbsp; Return $GUI_RUNDEFMSG
EndFunc &nbsp; ;==&gt;_WM_COMMAND


Func _Alive()
&nbsp; &nbsp; If $started = True Then
&nbsp; &nbsp; &nbsp; &nbsp; $aliveStatus += 2
&nbsp; &nbsp; &nbsp; &nbsp; If $aliveStatus &gt; 102 Then $aliveStatus = 0
&nbsp; &nbsp; &nbsp; &nbsp; GUICtrlSetData($alive, $aliveStatus)
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Return
EndFunc &nbsp; ;==&gt;_Alive


Func _Exit()
&nbsp; &nbsp; $reallyQuit = MsgBox(4, "Quit?", "Are you sure you want to quit?")
&nbsp; &nbsp; If $reallyQuit = 6 Then Exit
&nbsp; &nbsp; Return
EndFunc &nbsp; ;==&gt;_Exit