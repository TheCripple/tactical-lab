<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"></head><body><pre>#cs ----------------------------------------------------------------------------

AutoIt Version: 3.3.8.1 (Or greater)
Author: &nbsp; &nbsp; &nbsp;Ken Piper

Script Function:
&nbsp; &nbsp; Template multi-client server base code.
&nbsp; &nbsp; Use as a base for making an efficient server program.

&nbsp; &nbsp; This base will just accept connections and echo back what it receives,
&nbsp; &nbsp; &nbsp; &nbsp; and kill the connection if it is dead or inactive for x seconds.
&nbsp; &nbsp; It will not do any other work, that must be added seperately!

#ce ----------------------------------------------------------------------------

TCPStartup()
Opt("TCPTimeout", 0)

#region ;Safe-to-edit things are below
Global $BindIP = "0.0.0.0" &nbsp; &nbsp;;Listen on all addresses
Global $BindPort = 8080 &nbsp; &nbsp; &nbsp; &nbsp;;Listen on port 8080
Global $Timeout = 15000 &nbsp; &nbsp; &nbsp; &nbsp;;Max idle time is 15 seconds before calling a connection "dead"
Global $PacketSize = 2048 &nbsp; &nbsp;;Max packet size per-check is 2KB
Global $MaxClients = 50 &nbsp; &nbsp; &nbsp; &nbsp;;Max simultaneous clients is 50
#endregion ;Stuff you shouldn't touch is below

Global $Listen
Global $Clients[1][4] ;[Index][Socket, IP, Timestamp, Buffer]
Global $Ws2_32 = DllOpen("Ws2_32.dll") ;Open Ws2_32.dll, it might get used a lot
Global $NTDLL = DllOpen("ntdll.dll") ;Open ntdll.dll, it WILL get used a lot
Global $CleanupTimer = TimerInit() ;This is used to time when things should be cleaned up

OnAutoItExitRegister("Close") ;Register this function to be called if the server needs to exit

$Clients[0][0] = 0
$Listen = TCPListen($BindIP, $BindPort, $MaxClients) ;Start listening on the given IP/port
If @error Then Exit 1 ;Exit with return code 1 if something was already bound to that IP and port

While 1
&nbsp; &nbsp; USleep(5000, $NTDLL) ;This is needed because TCPTimeout is disabled. Without this it will run one core at ~100%.
&nbsp; &nbsp; ;The USleep function takes MICROseconds, not milliseconds, so 1000 = 1ms delay.
&nbsp; &nbsp; ;When working with this granularity, you have to take in to account the time it takes to complete USleep().
&nbsp; &nbsp; ;1000us (1ms) is about as fast as this should be set. If you need more performance, set this from 5000 to 1000,
&nbsp; &nbsp; ;but doing so will make it consume a bit more CPU time to get that extra bit of performance.
&nbsp; &nbsp; Check() ;Check recv buffers and do things
&nbsp; &nbsp; If TimerDiff($CleanupTimer) &gt; 1000 Then ;If it has been more than 1000ms since Cleanup() was last called, call it now
&nbsp; &nbsp; &nbsp; &nbsp; $CleanupTimer = TimerInit() ;Reset $CleanupTimer, so it is ready to be called again
&nbsp; &nbsp; &nbsp; &nbsp; Cleanup() ;Clean up the dead connections
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Local $iSock = TCPAccept($Listen) ;See if anything wants to connect
&nbsp; &nbsp; If $iSock = -1 Then ContinueLoop ;If nothing wants to connect, restart at the top of the loop
&nbsp; &nbsp; Local $iSize = UBound($Clients, 1) ;Something wants to connect, so get the number of people currently connected here
&nbsp; &nbsp; If $iSize - 1 &gt; $MaxClients And $MaxClients &gt; 0 Then ;If $MaxClients is greater than 0 (meaning if there is a max connection limit) then check if that has been reached
&nbsp; &nbsp; &nbsp; &nbsp; TCPCloseSocket($iSock) ;It has been reached, close the new connection and continue back at the top of the loop
&nbsp; &nbsp; &nbsp; &nbsp; ContinueLoop
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; ReDim $Clients[$iSize + 1][4] ;There is room for a new connection, allocate space for it here
&nbsp; &nbsp; $Clients[0][0] = $iSize ;Update the number of connected clients
&nbsp; &nbsp; $Clients[$iSize][0] = $iSock ;Set the socket ID of the connection
&nbsp; &nbsp; $Clients[$iSize][1] = SocketToIP($iSock, $Ws2_32) ;Set the IP Address the connection is from
&nbsp; &nbsp; $Clients[$iSize][2] = TimerInit() ;Set the timestamp for the last known activity timer
&nbsp; &nbsp; $Clients[$iSize][3] = "" ;Blank the recv buffer
WEnd

Func Check() ;Function for processing
&nbsp; &nbsp; If $Clients[0][0] &lt; 1 Then Return ;If there are no clients connected, stop the function right now
&nbsp; &nbsp; For $i = 1 To $Clients[0][0] ;Loop through all connected clients
&nbsp; &nbsp; &nbsp; &nbsp; $sRecv = TCPRecv($Clients[$i][0], $PacketSize) ;Read $PacketSize bytes from the current client's buffer
&nbsp; &nbsp; &nbsp; &nbsp; If $sRecv &lt;&gt; "" Then $Clients[$i][3] &amp;= $sRecv ;If there was more data sent from the client, add it to the buffer
&nbsp; &nbsp; &nbsp; &nbsp; If $Clients[$i][3] = "" Then ContinueLoop ;If the buffer is empty, stop right here and check more clients
&nbsp; &nbsp; &nbsp; &nbsp; $Clients[$i][2] = TimerInit() ;If it got this far, there is data to be parsed, so update the activity timer
&nbsp; &nbsp; &nbsp; &nbsp; #region ;Example packet processing stuff here. This is handling for a simple "echo" server with per-packet handling
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $sRecv = StringLeft($Clients[$i][3], StringInStr($Clients[$i][3], @CRLF, 0, -1)) ;Pull all data to the left of the last @CRLF in the buffer
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This does NOT pull the first complete packet, this pulls ALL complete packets, leaving only potentially incomplete packets in the buffer
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If $sRecv = "" Then ContinueLoop ;Check if there were any complete "packets"
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Clients[$i][3] = StringTrimLeft($Clients[$i][3], StringLen($sRecv) + 1) ;remove what was just read from the client's buffer
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $sPacket = StringSplit($sRecv, @CRLF, 1) ;Split all complete packets up in to an array, so it is easy to work with them
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $j = 1 To $sPacket[0] ;Loop through each complete packet; This is where any packet processing should be done
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TCPSend($Clients[$i][0], "Echoing line: " &amp; $sPacket[$j] &amp; @CRLF) ;Echo back the packet the client sent
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; #endregion ;Example
&nbsp; &nbsp; Next
EndFunc

Func Cleanup() ;Clean up any disconnected clients to regain resources
&nbsp; &nbsp; If $Clients[0][0] &lt; 1 Then Return ;If no clients are connected then return
&nbsp; &nbsp; Local $iNewSize = 0
&nbsp; &nbsp; For $i = 1 To $Clients[0][0] ;Loop through all connected clients
&nbsp; &nbsp; &nbsp; &nbsp; $Clients[$i][3] &amp;= TCPRecv($Clients[$i][0], $PacketSize) ;Dump any data not-yet-seen in to their recv buffer
&nbsp; &nbsp; &nbsp; &nbsp; If @error &gt; 0 Or TimerDiff($Clients[$i][2]) &gt; $Timeout Then ;Check to see if the connection has been inactive for a while or if there was an error
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TCPCloseSocket($Clients[$i][0]) ;If yes, close the connection
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Clients[$i][0] = -1 ;Set the socket ID to an invalid socket
&nbsp; &nbsp; &nbsp; &nbsp; Else
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $iNewSize += 1
&nbsp; &nbsp; &nbsp; &nbsp; EndIf
&nbsp; &nbsp; Next
&nbsp; &nbsp; If $iNewSize &lt; $Clients[0][0] Then ;If any dead connections were found, drop them from the client array and resize the array
&nbsp; &nbsp; &nbsp; &nbsp; Local $iSize = UBound($Clients, 2) - 1
&nbsp; &nbsp; &nbsp; &nbsp; Local $aTemp[$iNewSize + 1][$iSize + 1]
&nbsp; &nbsp; &nbsp; &nbsp; Local $iCount = 1
&nbsp; &nbsp; &nbsp; &nbsp; For $i = 1 To $Clients[0][0]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If $Clients[$i][0] = -1 Then ContinueLoop
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For $j = 0 To $iSize
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aTemp[$iCount][$j] = $Clients[$i][$j]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $iCount += 1
&nbsp; &nbsp; &nbsp; &nbsp; Next
&nbsp; &nbsp; &nbsp; &nbsp; $aTemp[0][0] = $iNewSize
&nbsp; &nbsp; &nbsp; &nbsp; $Clients = $aTemp
&nbsp; &nbsp; EndIf
EndFunc

Func Close()
&nbsp; &nbsp; DllClose($Ws2_32) ;Close the open handle to Ws2_32.dll
&nbsp; &nbsp; DllClose($NTDLL) ;Close the open handle to ntdll.dll
&nbsp; &nbsp; For $i = 1 To $Clients[0][0] ;Loop through the connected clients
&nbsp; &nbsp; &nbsp; &nbsp; TCPCloseSocket($Clients[$i][0]) ;Force the client's connection closed
&nbsp; &nbsp; Next
&nbsp; &nbsp; TCPShutdown() ;Shut down networking stuff
EndFunc

Func SocketToIP($iSock, $hDLL = "Ws2_32.dll") ;A rewrite of that _SocketToIP function that has been floating around for ages
&nbsp; &nbsp; Local $structName = DllStructCreate("short;ushort;uint;char[8]")
&nbsp; &nbsp; Local $sRet = DllCall($hDLL, "int", "getpeername", "int", $iSock, "ptr", DllStructGetPtr($structName), "int*", DllStructGetSize($structName))
&nbsp; &nbsp; If Not @error Then
&nbsp; &nbsp; &nbsp; &nbsp; $sRet = DllCall($hDLL, "str", "inet_ntoa", "int", DllStructGetData($structName, 3))
&nbsp; &nbsp; &nbsp; &nbsp; If Not @error Then Return $sRet[0]
&nbsp; &nbsp; EndIf
&nbsp; &nbsp; Return "0.0.0.0" ;Something went wrong, return an invalid IP
EndFunc

Func USleep($iUsec, $hDLL = "ntdll.dll") ;A rewrite of the _HighPrecisionSleep function made by monoceres (Thanks!)
&nbsp; &nbsp; Local $hStruct = DllStructCreate("int64")
&nbsp; &nbsp; DllStructSetData($hStruct, 1, -1 * ($iUsec * 10))
&nbsp; &nbsp; DllCall($hDLL, "dword", "ZwDelayExecution", "int", 0, "ptr", DllStructGetPtr($hStruct))
EndFunc</pre></body></html>