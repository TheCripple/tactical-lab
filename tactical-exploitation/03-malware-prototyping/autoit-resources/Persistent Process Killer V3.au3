#region ;**** Directives created by AutoIt3Wrapper_GUI ****
#AutoIt3Wrapper_UseUpx=n
#AutoIt3Wrapper_Run_Tidy=y
#endregion ;**** Directives created by AutoIt3Wrapper_GUI ****

;~ Coded by Ian Maxwell (llewxam)
;~ AutoIt 3.3.6.1

#include &lt;WindowsConstants.au3           ;needed for $WS_CAPTION, $WS_VSCROLL, $WM_COMMAND
#include &lt;array.au3                ;needed for _ArrayAdd, _ArrayDelete, _ArrayUnique, _ArraySort, _ArrayBinarySearch
#include &lt;ProgressConstants.au3          ;needed for $PBS_SMOOTH, $PBS_MARQUEE
#include &lt;GuiListBox.au3              ;needed for $LBS_NOTIFY, $LBS_SORT, $LBS_NOSEL, $GUI_RUNDEFMSG, _GUICtrlListBox_* functions

AdlibRegister("_Alive", 50)
AdlibRegister("_Scan")

$exceptionList = "PPK3.exe,[System
 
Process],System,smss.exe,csrss.exe,wininit.exe,csrss.exe,services.exe,winlogon.exe,lsass.exe,lsm.exe,svchost.exe,atiesrxx.exe,audiodg.exe,CTAudSvc.exe,atieclxx.exe,spoolsv.exe,taskhost.exe,dwm.exe,explorer.exe,rundll32.exe,GoogleCrashHandler.exe,MOM.exe,CCC.exe,SearchIndexer.exe,wmpnetwk.exe,SearchProtocolHost.exe,SearchFilterHost.exe,dllhost.exe,mpcmdrun.exe,msiexec.exe,unsecapp.exe,vds.exe,WmiPrvSE.exe"
$exceptions = StringSplit($exceptionList, ",") ;list of what not to kill
Local $pList[1] ;list of running processes
$pListOld = $pList ;to compare a previous process list, so $liveProc is only updated if the process list changes
Local $killList[1] ;list of processes to kill
$liveProcCount = 0 ;tally of processes running
$killProcCount = 0 ;tally of processes to be killed
$killListTrimmed = False ;flag for detecting when $killList has been trimmed
$goNuclear = False ;flag set by /nuke command line switch
$started = False ;used in Nuke mode to avoid crashes due to no GUI


;check for and run nuke
If $CmdLine[0] Then ;many viruses/spyware apps suppress EXEs from running, nuke mode is meant to sneak
  For $c = 1 To $CmdLine[0] ;PPK in before it can be suppressed. Just run "ppk /nuke" or "ppk nuke" repeatedly until it starts
    If StringLower($CmdLine[$c]) == "/nuke" Or StringLower($CmdLine[$c]) == "nuke" Then $goNuclear = True
  Next
EndIf
If $goNuclear == True Then
  $pListRaw = ProcessList()
  If @error Then
    MsgBox(48, "ERROR", "The process list could not be built!")
    Exit
  EndIf
  Local $pListTemp[1] ;used to get the list of running processes down to a 1-dimensional array
  For $a = 1 To $pListRaw[0][0]
    _ArrayAdd($pListTemp, $pListRaw[$a][0])
  Next
  _ArrayDelete($pListTemp, 0)
  $pList = _ArrayUnique($pListTemp)

  If $pList[0]  0 Then
    Local $killList[1]
    For $a = 1 To $pList[0]
      For $b = 1 To $exceptions[0]
        If StringLower($pList[$a]) == StringLower($exceptions[$b]) Then ContinueLoop (2)
      Next
      _Execute($pList[$a])
      _ArrayAdd($killList, $pList[$a])
    Next
  EndIf
  _ArrayDelete($killList, 0)
  $goNuclear = False
EndIf


;configure GUI
$vert = ((@DesktopHeight - 80) / 3) - 40
$PPKGUI = GUICreate("Persistent Process Killer", 200, @DesktopHeight - 70, @DesktopWidth - 205, 0, $WS_CAPTION)
$alive = GUICtrlCreateProgress(5, 5, 190, 20, BitOR($PBS_SMOOTH, $PBS_MARQUEE)) ;just to let the user know the app is still running
$aliveStatus = 0
$closeButton = GUICtrlCreateButton("Close", 75, 35, 50, 20)
$liveProcLabel = GUICtrlCreateLabel("Running Processes:", 5, 65, 190)
$liveProc = GUICtrlCreateList("", 5, 80, 190, $vert, BitOR($WS_VSCROLL, $LBS_NOTIFY, $LBS_SORT))
$killProcLabel = GUICtrlCreateLabel("Processes to Kill:", 5, $vert + 85, 190)
$killProc = GUICtrlCreateList("", 5, $vert + 100, 190, $vert, BitOR($WS_VSCROLL, $LBS_NOTIFY, $LBS_SORT))
GUICtrlCreateLabel("Errors:", 5, $vert * 2 + 105)
$errors = GUICtrlCreateList("", 5, $vert * 2 + 120, 190, $vert, BitOR($WS_VSCROLL, $LBS_SORT, $LBS_NOSEL))
GUISetState(@SW_SHOW, $PPKGUI)
GUIRegisterMsg($WM_COMMAND, "_WM_COMMAND")
WinSetOnTop("Persistent Process Killer", "", 1)


;perform initial scan for running processes
$pListRaw = ProcessList()
If @error Then
  MsgBox(48, "ERROR", "The process list could not be built!")
  Exit
EndIf
Local $pListTemp[1]
For $a = 1 To $pListRaw[0][0]
  _ArrayAdd($pListTemp, $pListRaw[$a][0])
Next
_ArrayDelete($pListTemp, 0)
$pList = _ArrayUnique($pListTemp)

If $pList[0]  0 Then
  For $a = 1 To $pList[0]
    For $b = 1 To $exceptions[0]
      If StringLower($pList[$a]) == StringLower($exceptions[$b]) Then ContinueLoop (2)
    Next
    GUICtrlSetData($liveProc, $pList[$a])
    $liveProcCount += 1
  Next
EndIf
GUICtrlSetData($liveProcLabel, "Running Processes: " &amp; $liveProcCount)

For $a = 1 To UBound($killList) - 1
  GUICtrlSetData($killProc, $killList[$a])
  $killProcCount += 1
Next
GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)

$started = True ;now all GUI controls will be used


;main loop
Do
  $msg = GUIGetMsg()
  If $msg = $closeButton Then _Exit()

  For $a = 1 To UBound($killList) - 1

    ;placed this check at beginning and end of loop so when $killList is decreased an out-of-range error will be avoided
    If $killListTrimmed == True Then
      $killListTrimmed = False
      ExitLoop
    EndIf

    If ProcessExists($killList[$a]) Then
      _Execute($killList[$a])
    EndIf

    If $killListTrimmed == True Then
      $killListTrimmed = False
      ExitLoop
    EndIf
  Next
Until 1 = 2


Func _Scan()
  If $started == True Then
    $pListOld = $pList
    $pListRaw = ProcessList()
    If @error Then
      MsgBox(48, "ERROR", "The process list could not be built!")
      Exit
    EndIf

    Local $pListTemp[1]
    For $a = 1 To $pListRaw[0][0]
      _ArrayAdd($pListTemp, $pListRaw[$a][0])
    Next
    _ArrayDelete($pListTemp, 0)
    $pList = _ArrayUnique($pListTemp)

    If $pList[0]  0 Then
      $refresh = False ;assume a refresh of $liveProc is not needed

      If $pList[0] &lt; $pListOld[0] Then
        $refresh = True ;different number of elements = refresh needed
      Else
        For $z = 1 To $pList[0]
          If $pList[$z] &lt; $pListOld[$z] Then $refresh = True ;something is not matching up, so a refresh is needed
        Next
      EndIf

      If $refresh = True Then
        $liveProcCount = 0
        _GUICtrlListBox_BeginUpdate($liveProc)
        _GUICtrlListBox_ResetContent($liveProc)
        For $a = 1 To $pList[0]
          For $b = 1 To $exceptions[0]
            If StringLower($pList[$a]) == StringLower($exceptions[$b]) Then ContinueLoop (2)
          Next
          _GUICtrlListBox_AddString($liveProc, $pList[$a])
          $liveProcCount += 1
        Next
        _GUICtrlListBox_EndUpdate($liveProc)
        GUICtrlSetData($liveProcLabel, "Running Processes: " &amp; $liveProcCount)
      EndIf
    EndIf
  EndIf
  Return
EndFunc  ;==_Scan


Func _Execute($victim)
  $killed = False
  $delay = TimerInit()
  Do
    ProcessClose($victim)
    If @error Then
      $status = @error
    Else
      $killed = True
      ExitLoop
    EndIf
    Sleep(50)
  Until TimerDiff($delay)  1000

  If $killed = False Then
    If $started == True Then
      GUICtrlSetData($errors, $victim &amp; " could not be killed! (" &amp; $status &amp; ")")
      _ArraySort($killList)
      $index = _ArrayBinarySearch($killList, $victim)
      _ArrayDelete($killList, $index)
      _GUICtrlListBox_BeginUpdate($killProc)
      _GUICtrlListBox_ResetContent($killProc)
      For $a = 1 To UBound($killList) - 1
        GUICtrlSetData($killProc, $killList[$a])
      Next
      _GUICtrlListBox_EndUpdate($killProc)
      $killProcCount -= 1
      GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)
      $killListTrimmed = True
    EndIf
  EndIf
  Return
EndFunc  ;==_Execute


Func _liveProc_DoubleClick()
  $sListItem = GUICtrlRead($liveProc)
  If $sListItem &lt; "" Then
    _ArrayAdd($killList, $sListItem)
    $killProcCount += 1
    GUICtrlSetData($killProc, $sListItem)
    GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)
  EndIf
  Return
EndFunc  ;==_liveProc_DoubleClick


Func _killProc_DoubleClick()
  $sListItem = GUICtrlRead($killProc)
  If $sListItem &lt; "" Then
    $killProcCount = 0
    _ArraySort($killList)
    $index = _ArrayBinarySearch($killList, $sListItem)
    _ArrayDelete($killList, $index)
    _GUICtrlListBox_BeginUpdate($killProc)
    _GUICtrlListBox_ResetContent($killProc)
    For $a = 1 To UBound($killList) - 1
      GUICtrlSetData($killProc, $killList[$a])
      $killProcCount += 1
    Next
    _GUICtrlListBox_EndUpdate($killProc)
    GUICtrlSetData($killProcLabel, "Processes to Kill: " &amp; $killProcCount)
    $killListTrimmed = True
  EndIf
  Return
EndFunc  ;==_killProc_DoubleClick


Func _WM_COMMAND($hWnd, $msg, $wParam, $lParam)
  Local $nNotifyCode = BitShift($wParam, 16)
  Local $nID = BitAND($wParam, 0xFFFF)
  Local Const $LBN_DBLCLK = 2

  Switch $nID
    Case $liveProc
      Switch $nNotifyCode
        Case $LBN_DBLCLK
          _liveProc_DoubleClick()
      EndSwitch
    Case $killProc
      Switch $nNotifyCode
        Case $LBN_DBLCLK
          _killProc_DoubleClick()
      EndSwitch
  EndSwitch
  Return $GUI_RUNDEFMSG
EndFunc  ;==_WM_COMMAND


Func _Alive()
  If $started = True Then
    $aliveStatus += 2
    If $aliveStatus  102 Then $aliveStatus = 0
    GUICtrlSetData($alive, $aliveStatus)
  EndIf
  Return
EndFunc  ;==_Alive


Func _Exit()
  $reallyQuit = MsgBox(4, "Quit?", "Are you sure you want to quit?")
  If $reallyQuit = 6 Then Exit
  Return
EndFunc  ;==_Exit